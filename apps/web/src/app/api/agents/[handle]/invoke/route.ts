import { NextRequest, NextResponse } from 'next/server';
import { MOCK_AGENTS } from '@/lib/db';

// x402 Payment Requirements
interface X402PaymentRequired {
  version: '1';
  accepts: Array<{
    scheme: 'exact';
    network: string; // e.g., 'base-sepolia', 'base'
    maxAmountRequired: string;
    resource: string;
    description: string;
    mimeType: string;
    payTo: string; // wallet address
    maxTimeoutSeconds: number;
    asset: string; // e.g., USDC contract address
  }>;
  error?: string;
}

// POST /api/agents/[handle]/invoke - Invoke an agent skill
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ handle: string }> }
) {
  try {
    const { handle } = await params;
    const body = await request.json();
    const { skill, input, payment } = body;

    // Find agent
    const agent = MOCK_AGENTS.find(a => a.handle === handle);
    if (!agent) {
      return NextResponse.json({ error: 'Agent not found' }, { status: 404 });
    }

    // Check if agent is available
    if (agent.status === 'offline') {
      return NextResponse.json({ error: 'Agent is offline' }, { status: 503 });
    }

    // Find the requested skill
    const skillInfo = agent.capabilities.includes(skill) 
      ? { skillId: skill, price: '0.01' } // Mock price
      : null;

    if (!skillInfo) {
      return NextResponse.json({ 
        error: 'Skill not available',
        availableSkills: agent.capabilities,
      }, { status: 400 });
    }

    // Check for x402 payment header
    const paymentHeader = request.headers.get('X-PAYMENT');
    
    // If no payment provided, return 402 with payment requirements
    if (!paymentHeader && !payment && parseFloat(skillInfo.price) > 0) {
      const paymentRequired: X402PaymentRequired = {
        version: '1',
        accepts: [
          {
            scheme: 'exact',
            network: 'base-sepolia', // Test network
            maxAmountRequired: skillInfo.price,
            resource: `/api/agents/${handle}/invoke`,
            description: `Invoke ${skill} on ${agent.name}`,
            mimeType: 'application/json',
            payTo: '0x0000000000000000000000000000000000000000', // TODO: Agent's wallet
            maxTimeoutSeconds: 300,
            asset: '0x036CbD53842c5426634e7929541eC2318f3dCF7e', // USDC on Base Sepolia
          },
        ],
        error: 'Payment required to invoke this skill',
      };

      return NextResponse.json(paymentRequired, {
        status: 402,
        headers: {
          'X-PAYMENT-REQUIRED': 'true',
        },
      });
    }

    // If payment provided, verify it (mock verification for now)
    if (paymentHeader || payment) {
      // TODO: Implement x402 payment verification
      // 1. Decode the payment header
      // 2. Verify with x402 facilitator
      // 3. Confirm payment amount and recipient
      console.log('Payment received:', paymentHeader || payment);
    }

    // Mock agent invocation - in production this would:
    // 1. Forward to the agent's actual endpoint
    // 2. Track the transaction
    // 3. Update stats
    const mockResponse = {
      success: true,
      agentHandle: handle,
      skill,
      input,
      output: generateMockOutput(skill, input),
      executionTimeMs: Math.floor(Math.random() * 2000) + 500,
      transactionId: `txn_${crypto.randomUUID().split('-')[0]}`,
      timestamp: new Date().toISOString(),
      source: 'mock',
      note: 'This is a mock response. Real execution coming soon.',
    };

    return NextResponse.json(mockResponse);

  } catch (error) {
    console.error('Error invoking agent:', error);
    return NextResponse.json(
      { error: 'Failed to invoke agent' },
      { status: 500 }
    );
  }
}

// Generate mock output based on skill type
function generateMockOutput(skill: string, input: any): any {
  switch (skill) {
    case 'text-generation':
    case 'creative-writing':
    case 'copywriting':
      return {
        text: `This is a mock response for "${input?.prompt || input?.text || 'your request'}". In production, this would be generated by the actual AI agent.`,
        tokens: 42,
      };

    case 'code-generation':
      return {
        code: `// Mock code output for: ${input?.prompt || 'your request'}\nfunction example() {\n  return 'Hello, ClawdNet!';\n}`,
        language: input?.language || 'javascript',
      };

    case 'image-generation':
      return {
        imageUrl: 'https://placehold.co/512x512/1a1a2e/00ff88?text=Mock+Image',
        prompt: input?.prompt,
        width: 512,
        height: 512,
      };

    case 'translation':
      return {
        translatedText: `[Mock translation of: ${input?.text || 'your text'}]`,
        sourceLanguage: input?.from || 'auto',
        targetLanguage: input?.to || 'en',
      };

    case 'web-search':
    case 'research':
      return {
        results: [
          { title: 'Mock Result 1', url: 'https://example.com/1', snippet: 'This is a mock search result.' },
          { title: 'Mock Result 2', url: 'https://example.com/2', snippet: 'Another mock result.' },
        ],
        query: input?.query || input?.prompt,
      };

    case 'analysis':
    case 'fact-checking':
      return {
        analysis: 'Mock analysis result. The input appears to be valid.',
        confidence: 0.85,
        sources: ['mock-source-1', 'mock-source-2'],
      };

    default:
      return {
        result: `Mock output for skill: ${skill}`,
        input,
      };
  }
}
